{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab560
\pard\pardeftab560\slleading20\partightenfactor0

\f0\fs26 \cf0 using System;\
using System.Collections.Generic;\
using System.Text.RegularExpressions;\
\
abstract class Node\
\{\
    public abstract object Evaluate(Dictionary<string, object> context);\
\}\
\
class BinaryOp : Node\
\{\
    private Node Left, Right;\
    private string Op;\
\
    public BinaryOp(Node left, string op, Node right)\
    \{\
        Left = left;\
        Op = op;\
        Right = right;\
    \}\
\
    public override object Evaluate(Dictionary<string, object> context)\
    \{\
        dynamic leftVal = Left.Evaluate(context);\
        dynamic rightVal = Right.Evaluate(context);\
        return Op switch\
        \{\
            "and" => leftVal && rightVal,\
            "or" => leftVal || rightVal,\
            "==" => leftVal == rightVal,\
            "!=" => leftVal != rightVal,\
            ">" => leftVal > rightVal,\
            "<" => leftVal < rightVal,\
            ">=" => leftVal >= rightVal,\
            "<=" => leftVal <= rightVal,\
            _ => throw new Exception($"Unknown operator \{Op\}")\
        \};\
    \}\
\}\
\
class UnaryOp : Node\
\{\
    private Node Operand;\
    private string Op;\
\
    public UnaryOp(string op, Node operand)\
    \{\
        Op = op;\
        Operand = operand;\
    \}\
\
    public override object Evaluate(Dictionary<string, object> context)\
    \{\
        dynamic val = Operand.Evaluate(context);\
        return Op == "not" ? !val : val;\
    \}\
\}\
\
class BooleanLiteral : Node\
\{\
    private bool Value;\
    public BooleanLiteral(bool value) \{ Value = value; \}\
    public override object Evaluate(Dictionary<string, object> context) => Value;\
\}\
\
class NumericLiteral : Node\
\{\
    private double Value;\
    public NumericLiteral(string value) \{ Value = double.Parse(value); \}\
    public override object Evaluate(Dictionary<string, object> context) => Value;\
\}\
\
class StringLiteral : Node\
\{\
    private string Value;\
    public StringLiteral(string value) \{ Value = value.Trim('"'); \}\
    public override object Evaluate(Dictionary<string, object> context) => Value;\
\}\
\
class Variable : Node\
\{\
    private string Name;\
    public Variable(string name) \{ Name = name; \}\
    public override object Evaluate(Dictionary<string, object> context) => context.ContainsKey(Name) ? context[Name] : false;\
\}\
\
class FunctionCall : Node\
\{\
    private string FuncName;\
    private List<Node> Args;\
\
    public FunctionCall(string funcName, List<Node> args)\
    \{\
        FuncName = funcName;\
        Args = args;\
    \}\
\
    public override object Evaluate(Dictionary<string, object> context)\
    \{\
        if (!context.ContainsKey(FuncName) || context[FuncName] is not Func<object[], object> func)\
            throw new Exception($"Unknown function: \{FuncName\}");\
        return func(Args.ConvertAll(arg => arg.Evaluate(context)).ToArray());\
    \}\
\}\
\
class Parser\
\{\
    private List<string> Tokens;\
    private int Pos;\
\
    public Parser(List<string> tokens)\
    \{\
        Tokens = tokens;\
        Pos = 0;\
    \}\
\
    public Node Parse() => ParseOr();\
\
    private Node ParseOr()\
    \{\
        Node node = ParseAnd();\
        while (Match("or"))\
            node = new BinaryOp(node, "or", ParseAnd());\
        return node;\
    \}\
\
    private Node ParseAnd()\
    \{\
        Node node = ParseUnary();\
        while (Match("and"))\
            node = new BinaryOp(node, "and", ParseUnary());\
        return node;\
    \}\
\
    private Node ParseUnary()\
    \{\
        if (Match("not")) return new UnaryOp("not", ParseUnary());\
        return ParseComparison();\
    \}\
\
    private Node ParseComparison()\
    \{\
        Node node = ParseTerm();\
        while (Match("==", "!=", ">", "<", ">=", "<="))\
            node = new BinaryOp(node, Previous(), ParseTerm());\
        return node;\
    \}\
\
    private Node ParseTerm()\
    \{\
        if (Match("(")) \{ var node = Parse(); Consume(")"); return node; \}\
        if (Match("true")) return new BooleanLiteral(true);\
        if (Match("false")) return new BooleanLiteral(false);\
        if (double.TryParse(Peek(), out double numValue)) return new NumericLiteral(Advance());\
        if (Peek().StartsWith("\\"") && Peek().EndsWith("\\"")) return new StringLiteral(Advance());\
        if (MatchIdentifier())\
        \{\
            string name = Previous();\
            if (Match("("))\
            \{\
                var args = new List<Node>();\
                if (!Match(")"))\
                \{\
                    args.Add(Parse());\
                    while (Match(",")) args.Add(Parse());\
                    Consume(")");\
                \}\
                return new FunctionCall(name, args);\
            \}\
            return new Variable(name);\
        \}\
        throw new Exception($"Unexpected token: \{Peek()\}");\
    \}\
\
    private bool Match(params string[] expected)\
    \{\
        if (Pos < Tokens.Count && Array.Exists(expected, e => e == Tokens[Pos]))\
        \{\
            Pos++;\
            return true;\
        \}\
        return false;\
    \}\
\
    private bool MatchIdentifier() => Pos < Tokens.Count && Regex.IsMatch(Tokens[Pos], "^[A-Za-z_][A-Za-z0-9_]*$") && (Pos++ > 0);\
\
    private void Consume(string expected)\
    \{\
        if (Tokens[Pos] == expected) Pos++;\
        else throw new Exception($"Expected '\{expected\}', found '\{Peek()\}'");\
    \}\
\
    private string Advance() => Tokens[Pos++];\
    private string Previous() => Tokens[Pos - 1];\
    private string Peek() => Pos < Tokens.Count ? Tokens[Pos] : null;\
\}\
}