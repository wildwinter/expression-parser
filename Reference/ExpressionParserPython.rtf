{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab560
\pard\pardeftab560\slleading20\partightenfactor0

\f0\fs26 \cf0 import re\
\
DEBUG = True  # Set to False to disable debug prints\
\
TOKEN_REGEX = re.compile(r'\\s*(>=|<=|==|!=|>|<|\\(|\\)|,|and|or|not|[A-Za-z_][A-Za-z0-9_]*|\\d+\\.\\d+|\\d+|"[^"]*"|true|false)\\s*')\
\
def tokenize(expression):\
    tokens = TOKEN_REGEX.findall(expression)\
    if DEBUG:\
        print(f"Tokens: \{tokens\}")\
    return tokens\
\
class Node:\
    def evaluate(self, context):\
        raise NotImplementedError()\
\
    def debug_print(self, indent=0):\
        print("  " * indent + str(self))\
\
class BinaryOp(Node):\
    def __init__(self, left, op, right):\
        self.left = left\
        self.op = op\
        self.right = right\
\
    def evaluate(self, context):\
        left_val = self.left.evaluate(context)\
        right_val = self.right.evaluate(context)\
        result = None\
\
        if self.op == "and":\
            result = left_val and right_val\
        elif self.op == "or":\
            result = left_val or right_val\
        elif self.op == "==":\
            result = left_val == right_val\
        elif self.op == "!=":\
            result = left_val != right_val\
        elif self.op == ">":\
            result = left_val > right_val\
        elif self.op == "<":\
            result = left_val < right_val\
        elif self.op == ">=":\
            result = left_val >= right_val\
        elif self.op == "<=":\
            result = left_val <= right_val\
        \
        if DEBUG:\
            print(f"Evaluating: \{left_val\} \{self.op\} \{right_val\} -> \{result\}")\
        return result\
\
    def debug_print(self, indent=0):\
        print("  " * indent + f"BinaryOp(\{self.op\})")\
        self.left.debug_print(indent + 1)\
        self.right.debug_print(indent + 1)\
\
class UnaryOp(Node):\
    def __init__(self, op, operand):\
        self.op = op\
        self.operand = operand\
\
    def evaluate(self, context):\
        val = self.operand.evaluate(context)\
        result = not val if self.op == "not" else val\
        if DEBUG:\
            print(f"Evaluating: \{self.op\} \{val\} -> \{result\}")\
        return result\
\
    def debug_print(self, indent=0):\
        print("  " * indent + f"UnaryOp(\{self.op\})")\
        self.operand.debug_print(indent + 1)\
\
class BooleanLiteral(Node):\
    def __init__(self, value):\
        self.value = value\
\
    def evaluate(self, context):\
        if DEBUG:\
            print(f"Boolean literal: \{self.value\}")\
        return self.value\
\
    def debug_print(self, indent=0):\
        print("  " * indent + f"BooleanLiteral(\{self.value\})")\
\
class NumericLiteral(Node):\
    def __init__(self, value):\
        self.value = float(value) if '.' in value else int(value)\
\
    def evaluate(self, context):\
        if DEBUG:\
            print(f"Numeric literal: \{self.value\}")\
        return self.value\
\
    def debug_print(self, indent=0):\
        print("  " * indent + f"NumericLiteral(\{self.value\})")\
\
class Variable(Node):\
    def __init__(self, name):\
        self.name = name\
\
    def evaluate(self, context):\
        value = context.get(self.name, False)\
        if DEBUG:\
            print(f"Fetching variable: \{self.name\} -> \{value\}")\
        return value\
\
    def debug_print(self, indent=0):\
        print("  " * indent + f"Variable(\{self.name\})")\
\
class StringLiteral(Node):\
    def __init__(self, value):\
        self.value = value.strip('"')\
\
    def evaluate(self, context):\
        if DEBUG:\
            print(f"String literal: \{self.value\}")\
        return self.value\
\
    def debug_print(self, indent=0):\
        print("  " * indent + f"StringLiteral(\{self.value\})")\
\
class FunctionCall(Node):\
    def __init__(self, func_name, args=[]):\
        self.func_name = func_name\
        self.args = args\
\
    def evaluate(self, context):\
        func = context.get(self.func_name, lambda *args: False)\
        arg_values = [arg.evaluate(context) for arg in self.args]\
        result = func(*arg_values)\
        if DEBUG:\
            print(f"Calling function: \{self.func_name\}(\{arg_values\}) -> \{result\}")\
        return result\
\
    def debug_print(self, indent=0):\
        print("  " * indent + f"FunctionCall(\{self.func_name\})")\
        for arg in self.args:\
            arg.debug_print(indent + 1)\
\
class Parser:\
    def __init__(self, tokens):\
        self.tokens = tokens\
        self.pos = 0\
\
    def parse(self):\
        node = self.parse_or()\
        if DEBUG:\
            print("Parsed Expression Tree:")\
            node.debug_print()\
        return node\
\
    def parse_or(self):\
        node = self.parse_and()\
        while self.match("or"):\
            node = BinaryOp(node, "or", self.parse_and())\
        return node\
\
    def parse_and(self):\
        node = self.parse_unary()\
        while self.match("and"):\
            node = BinaryOp(node, "and", self.parse_unary())\
        return node\
\
    def parse_unary(self):\
        if self.match("not"):\
            return UnaryOp("not", self.parse_unary())\
        return self.parse_comparison()\
\
    def parse_comparison(self):\
        node = self.parse_term()\
        while self.match("==", "!=", ">", "<", ">=", "<="):\
            op = self.previous()\
            node = BinaryOp(node, op, self.parse_term())\
        return node\
\
    def parse_term(self):\
        if self.match("("):\
            node = self.parse()\
            self.consume(")")\
            return node\
        elif self.match("true"):\
            return BooleanLiteral(True)\
        elif self.match("false"):\
            return BooleanLiteral(False)\
        elif re.match(r'^\\d+(\\.\\d+)?$', self.peek()):\
            return NumericLiteral(self.advance())\
        elif self.peek().startswith("\\"") and self.peek().endswith("\\""):\
            return StringLiteral(self.advance())\
        elif self.match_identifier():\
            name = self.previous()\
            if self.match("("):\
                args = []\
                if not self.match(")"):\
                    args.append(self.parse())\
                    while self.match(","):\
                        args.append(self.parse())\
                    self.consume(")")\
                return FunctionCall(name, args)\
            return Variable(name)\
        raise SyntaxError(f"Unexpected token: \{self.peek()\}")\
}