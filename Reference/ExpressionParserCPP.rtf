{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab560
\pard\pardeftab560\slleading20\partightenfactor0

\f0\fs26 \cf0 #include <iostream>\
#include <string>\
#include <vector>\
#include <unordered_map>\
#include <functional>\
#include <memory>\
#include <stdexcept>\
#include <sstream>\
#include <regex>\
\
class Node \{\
public:\
    virtual ~Node() = default;\
    virtual std::any evaluate(const std::unordered_map<std::string, std::any>& context) const = 0;\
\};\
\
class BinaryOp : public Node \{\
    std::unique_ptr<Node> left, right;\
    std::string op;\
public:\
    BinaryOp(std::unique_ptr<Node> left, std::string op, std::unique_ptr<Node> right)\
        : left(std::move(left)), op(std::move(op)), right(std::move(right)) \{\}\
\
    std::any evaluate(const std::unordered_map<std::string, std::any>& context) const override \{\
        auto leftVal = std::any_cast<double>(left->evaluate(context));\
        auto rightVal = std::any_cast<double>(right->evaluate(context));\
        \
        if (op == "and") return leftVal && rightVal;\
        if (op == "or") return leftVal || rightVal;\
        if (op == "==") return leftVal == rightVal;\
        if (op == "!=") return leftVal != rightVal;\
        if (op == ">") return leftVal > rightVal;\
        if (op == "<") return leftVal < rightVal;\
        if (op == ">=") return leftVal >= rightVal;\
        if (op == "<=") return leftVal <= rightVal;\
        throw std::runtime_error("Unknown operator " + op);\
    \}\
\};\
\
class UnaryOp : public Node \{\
    std::unique_ptr<Node> operand;\
    std::string op;\
public:\
    UnaryOp(std::string op, std::unique_ptr<Node> operand)\
        : op(std::move(op)), operand(std::move(operand)) \{\}\
\
    std::any evaluate(const std::unordered_map<std::string, std::any>& context) const override \{\
        auto val = std::any_cast<bool>(operand->evaluate(context));\
        return op == "not" ? !val : val;\
    \}\
\};\
\
class BooleanLiteral : public Node \{\
    bool value;\
public:\
    BooleanLiteral(bool value) : value(value) \{\}\
    std::any evaluate(const std::unordered_map<std::string, std::any>& context) const override \{ return value; \}\
\};\
\
class NumericLiteral : public Node \{\
    double value;\
public:\
    NumericLiteral(std::string value) : value(std::stod(value)) \{\}\
    std::any evaluate(const std::unordered_map<std::string, std::any>& context) const override \{ return value; \}\
\};\
\
class StringLiteral : public Node \{\
    std::string value;\
public:\
    StringLiteral(std::string value) : value(std::move(value)) \{\}\
    std::any evaluate(const std::unordered_map<std::string, std::any>& context) const override \{ return value; \}\
\};\
\
class Variable : public Node \{\
    std::string name;\
public:\
    Variable(std::string name) : name(std::move(name)) \{\}\
    std::any evaluate(const std::unordered_map<std::string, std::any>& context) const override \{\
        if (context.find(name) != context.end()) \{\
            return context.at(name);\
        \}\
        return false;\
    \}\
\};\
\
class FunctionCall : public Node \{\
    std::string funcName;\
    std::vector<std::unique_ptr<Node>> args;\
public:\
    FunctionCall(std::string funcName, std::vector<std::unique_ptr<Node>> args)\
        : funcName(std::move(funcName)), args(std::move(args)) \{\}\
\
    std::any evaluate(const std::unordered_map<std::string, std::any>& context) const override \{\
        if (context.find(funcName) == context.end() || !context.at(funcName).has_value()) \{\
            throw std::runtime_error("Unknown function: " + funcName);\
        \}\
        auto func = std::any_cast<std::function<std::any(std::vector<std::any>)>>(context.at(funcName));\
        std::vector<std::any> argValues;\
        for (const auto& arg : args) \{\
            argValues.push_back(arg->evaluate(context));\
        \}\
        return func(argValues);\
    \}\
\};\
\
class Parser \{\
    std::vector<std::string> tokens;\
    size_t pos;\
\
public:\
    explicit Parser(std::vector<std::string> tokens) : tokens(std::move(tokens)), pos(0) \{\}\
\
    std::unique_ptr<Node> parse() \{\
        return parseOr();\
    \}\
\
private:\
    std::unique_ptr<Node> parseOr() \{\
        auto node = parseAnd();\
        while (match("or")) \{\
            node = std::make_unique<BinaryOp>(std::move(node), "or", parseAnd());\
        \}\
        return node;\
    \}\
\
    std::unique_ptr<Node> parseAnd() \{\
        auto node = parseUnary();\
        while (match("and")) \{\
            node = std::make_unique<BinaryOp>(std::move(node), "and", parseUnary());\
        \}\
        return node;\
    \}\
\
    std::unique_ptr<Node> parseUnary() \{\
        if (match("not")) \{\
            return std::make_unique<UnaryOp>("not", parseUnary());\
        \}\
        return parseComparison();\
    \}\
\
    std::unique_ptr<Node> parseComparison() \{\
        auto node = parseTerm();\
        while (match("==", "!=", ">", "<", ">=", "<=")) \{\
            std::string op = previous();\
            node = std::make_unique<BinaryOp>(std::move(node), op, parseTerm());\
        \}\
        return node;\
    \}\
\
   std::unique_ptr<Node> parseTerm() \{\
        if (match("(")) \{\
            auto node = parse();\
            consume(")");\
            return node;\
        \} else if (match("true")) \{\
            return std::make_unique<BooleanLiteral>(true);\
        \} else if (match("false")) \{\
            return std::make_unique<BooleanLiteral>(false);\
        \} else if (std::regex_match(peek(), std::regex("^\\\\d+(\\\\.\\\\d+)?$"))) \{\
            return std::make_unique<NumericLiteral>(advance());\
        \} else if (peek().front() == '"' && peek().back() == '"') \{\
            return std::make_unique<StringLiteral>(advance());\
        \} else if (matchIdentifier()) \{\
            std::string name = previous();\
            if (match("(")) \{\
                std::vector<std::unique_ptr<Node>> args;\
                if (!match(")")) \{\
                    args.push_back(parse());\
                    while (match(",")) \{\
                        args.push_back(parse());\
                    \}\
                    consume(")");\
                \}\
                return std::make_unique<FunctionCall>(name, std::move(args));\
            \}\
            return std::make_unique<Variable>(name);\
        \}\
        throw std::runtime_error("Unexpected token: " + peek());\
    \}\
\
    bool match(const std::string& expected) \{\
        if (pos < tokens.size() && tokens[pos] == expected) \{\
            pos++;\
            return true;\
        \}\
        return false;\
    \}\
\
    bool match(const std::vector<std::string>& expected) \{\
        if (pos < tokens.size() && std::find(expected.begin(), expected.end(), tokens[pos]) != expected.end()) \{\
            pos++;\
            return true;\
        \}\
        return false;\
    \}\
\
    bool matchIdentifier() \{\
        return pos < tokens.size() && std::regex_match(tokens[pos], std::regex("^[A-Za-z_][A-Za-z0-9_]*$")) && (++pos);\
    \}\
\
    void consume(const std::string& expected) \{\
        if (!match(expected)) \{\
            throw std::runtime_error("Expected '" + expected + "', found '" + peek() + "'");\
        \}\
    \}\
\
    std::string advance() \{ return tokens[pos++]; \}\
    std::string previous() \{ return tokens[pos - 1]; \}\
    std::string peek() \{ return pos < tokens.size() ? tokens[pos] : ""; \}\
\};\
\
class Tokenizer \{\
public:\
    static std::vector<std::string> tokenize(const std::string& input) \{\
        std::regex tokenRegex("\\\\s*(>=|<=|==|!=|>|<|\\\\(|\\\\)|,|and|or|not|[A-Za-z_][A-Za-z0-9_]*|\\\\d+(\\\\.\\\\d+)?|\\\\\\"[^\\\\\\"]*\\\\\\"|true|false)\\\\s*");\
        std::sregex_iterator begin(input.begin(), input.end(), tokenRegex), end;\
        std::vector<std::string> tokens;\
        for (auto it = begin; it != end; ++it) \{\
            tokens.push_back(it->str());\
        \}\
        return tokens;\
    \}\
\};\
\
int main() \{\
    std::string expression = "(x >= 10 and y < 5) or is_even(x)";\
    auto tokens = Tokenizer::tokenize(expression);\
    Parser parser(tokens);\
    auto exprTree = parser.parse();\
    \
    std::unordered_map<std::string, std::any> context = \{\
        \{"x", 12\},\
        \{"y", 3\},\
        \{"is_even", [](std::vector<std::any> args) -> std::any \{\
            int num = std::any_cast<int>(args[0]);\
            return num % 2 == 0;\
        \}\}\
    \};\
\
    bool result = std::any_cast<bool>(exprTree->evaluate(context));\
    std::cout << "Evaluation Result: " << result << std::endl;\
    return 0;\
\}}