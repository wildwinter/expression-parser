{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 class Node \{\
    evaluate(context) \{\
        throw new Error("evaluate() must be implemented");\
    \}\
\
    debugPrint(indent = 0) \{\
        console.log("  ".repeat(indent) + this.constructor.name);\
    \}\
\}\
\
class BinaryOp extends Node \{\
    constructor(left, op, right) \{\
        super();\
        this.left = left;\
        this.op = op;\
        this.right = right;\
    \}\
\
    evaluate(context) \{\
        const leftVal = this.left.evaluate(context);\
        const rightVal = this.right.evaluate(context);\
        let result;\
\
        switch (this.op) \{\
            case "and": result = leftVal && rightVal; break;\
            case "or": result = leftVal || rightVal; break;\
            case "==": result = leftVal === rightVal; break;\
            case "!=": result = leftVal !== rightVal; break;\
            case ">": result = leftVal > rightVal; break;\
            case "<": result = leftVal < rightVal; break;\
            case ">=": result = leftVal >= rightVal; break;\
            case "<=": result = leftVal <= rightVal; break;\
            default: throw new Error(`Unknown operator $\{this.op\}`);\
        \}\
        return result;\
    \}\
\}\
\
class UnaryOp extends Node \{\
    constructor(op, operand) \{\
        super();\
        this.op = op;\
        this.operand = operand;\
    \}\
\
    evaluate(context) \{\
        const val = this.operand.evaluate(context);\
        return this.op === "not" ? !val : val;\
    \}\
\}\
\
class BooleanLiteral extends Node \{\
    constructor(value) \{\
        super();\
        this.value = value;\
    \}\
\
    evaluate() \{\
        return this.value;\
    \}\
\}\
\
class NumericLiteral extends Node \{\
    constructor(value) \{\
        super();\
        this.value = value.includes('.') ? parseFloat(value) : parseInt(value, 10);\
    \}\
\
    evaluate() \{\
        return this.value;\
    \}\
\}\
\
class StringLiteral extends Node \{\
    constructor(value) \{\
        super();\
        this.value = value.replace(/^"|"$/g, '');\
    \}\
\
    evaluate() \{\
        return this.value;\
    \}\
\}\
\
class Variable extends Node \{\
    constructor(name) \{\
        super();\
        this.name = name;\
    \}\
\
    evaluate(context) \{\
        return context[this.name] || false;\
    \}\
\}\
\
class FunctionCall extends Node \{\
    constructor(funcName, args = []) \{\
        super();\
        this.funcName = funcName;\
        this.args = args;\
    \}\
\
    evaluate(context) \{\
        const func = context[this.funcName];\
        if (typeof func !== 'function') \{\
            throw new Error(`Unknown function: $\{this.funcName\}`);\
        \}\
        return func(...this.args.map(arg => arg.evaluate(context)));\
    \}\
\}\
\
class Parser \{\
    constructor(tokens) \{\
        this.tokens = tokens;\
        this.pos = 0;\
    \}\
\
    parse() \{\
        return this.parseOr();\
    \}\
\
    parseOr() \{\
        let node = this.parseAnd();\
        while (this.match("or")) \{\
            node = new BinaryOp(node, "or", this.parseAnd());\
        \}\
        return node;\
    \}\
\
    parseAnd() \{\
        let node = this.parseUnary();\
        while (this.match("and")) \{\
            node = new BinaryOp(node, "and", this.parseUnary());\
        \}\
        return node;\
    \}\
\
    parseUnary() \{\
        if (this.match("not")) \{\
            return new UnaryOp("not", this.parseUnary());\
        \}\
        return this.parseComparison();\
    \}\
\
    parseComparison() \{\
        let node = this.parseTerm();\
        while (this.match("==", "!=", ">", "<", ">=", "<=")) \{\
            const op = this.previous();\
            node = new BinaryOp(node, op, this.parseTerm());\
        \}\
        return node;\
    \}\
\
    parseTerm() \{\
        if (this.match("(")) \{\
            const node = this.parse();\
            this.consume(")");\
            return node;\
        \} else if (this.match("true")) \{\
            return new BooleanLiteral(true);\
        \} else if (this.match("false")) \{\
            return new BooleanLiteral(false);\
        \} else if (/^\\d+(\\.\\d+)?$/.test(this.peek())) \{\
            return new NumericLiteral(this.advance());\
        \} else if (/^".*"$/.test(this.peek())) \{\
            return new StringLiteral(this.advance());\
        \} else if (this.matchIdentifier()) \{\
            const name = this.previous();\
            if (this.match("(")) \{\
                const args = [];\
                if (!this.match(")")) \{\
                    args.push(this.parse());\
                    while (this.match(",")) \{\
                        args.push(this.parse());\
                    \}\
                    this.consume(")");\
                \}\
                return new FunctionCall(name, args);\
            \}\
            return new Variable(name);\
        \}\
        throw new Error(`Unexpected token: $\{this.peek()\}`);\
    \}\
\
    match(...expected) \{\
        if (this.pos < this.tokens.length && expected.includes(this.tokens[this.pos])) \{\
            this.pos++;\
            return true;\
        \}\
        return false;\
    \}\
\
    matchIdentifier() \{\
        if (this.pos < this.tokens.length && /^[A-Za-z_][A-Za-z0-9_]*$/.test(this.tokens[this.pos])) \{\
            this.pos++;\
            return true;\
        \}\
        return false;\
    \}\
\
    consume(expected) \{\
        if (this.tokens[this.pos] === expected) \{\
            this.pos++;\
        \} else \{\
            throw new Error(`Expected '$\{expected\}', found '$\{this.peek()\}'`);\
        \}\
    \}\
\
    advance() \{\
        return this.tokens[this.pos++];\
    \}\
\
    previous() \{\
        return this.tokens[this.pos - 1];\
    \}\
\
    peek() \{\
        return this.tokens[this.pos] || null;\
    \}\
\}\
}